# Lecture 9. Database language SQL

<h3>Abstract</h3>

<p><a name="Sql"><i>SQL</i></a> (= <i> Structured Query Language</i>) is the dedicated language 
which allows accessing and processing data stored in a relational database.
It operates on the level of objects of the relational model, i.e.
<i>tables</i> and <i>views</i>. SQL is a standard adopted by ANSI and ISO.</p>

<p>SQL may be also used in programs written in conventional programming languages.
There are interfaces to use SQL in C, C++, Java, Visual Basic and many others.
Two of the further lectures describe SQL interfaces for Visual Basic and Java.</p>

<p>There are also <i>4GL</i> (= <i>4th Generation Language</i>) programming environments 
where client applications are automatically generated by tools
(like Oracle Forms and MS Access) and it is not necessary to write traditional programs.</p>

<p>Lecture 9 describes fundamental kinds of SQL statements.  You have to know them,
if you want to create a database application in any environment.  In particular,
SQL is used in MS Access.</p>

<hr><h3><a name="intro">Introduction</a></h3>

<p>In this lecture we will describe the fundamental statements of SQL.  As the running
example we will use the database <i>Invoices</i> which has the following schema.

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_01.png"></p>

<p>Note the type of the relationship between <i>Invoices</i> and
<i>Employees</i>.  It is defined to be the outer join.  Therefore, whenever we join these tables,
we want to see pairs of matched invoices and employees as well as the invoices
which are not related to any employee.</p>

<p>We will execute the queries in the MS Access environment.  Lecture 2 has presented
the way to create queries in the design view by means of the query grid.  Queries have
one more view. It is <i>the SQL view</i>.  The simplest way to obtain an SQL statement
is to create a view in the design view and then switch to  the SQL view. However, this works
in MS Access only.  Therefore, during this lecture we will use 
the direct method.  We will
simply write SQL code.</p>

<p>We encourage you to test the presented statements.  In order to do it, create 
a database <i>Invoices</i> with the schema shown above and enter sample data.</p>
 
<hr><h3><a name="Select">SELECT statement</a></h3>

<p>The SELECT statement retrieves data from the database. It consists of parts called
<i>clauses</i>:</p>

<dl>
<dt><b><code>FROM</code></b>
<dd>What tables provide data for the query?
<dt><b><code>WHERE</code></b>
<dd>What conditions are to be fulfilled by the data?
<dt><b><code>SELECT</code></b>
<dd>What is the form of the result as presented to the user or the application?
</dl>

<table><tr><td class="notec">
  <code>SELECT <i>column_name</i>,...<br>
  FROM <i>table_name</i><br>
  WHERE <i>condition</i>;</code>
</table>

<p>The phrase <code>SELECT <i>column_name</i>,...</code> denotes a list of columns
separated with commas.  The WHERE clause is optional, thus an SQL statement may also look
as follows:</p>

<table><tr><td class="notec">
  <code>SELECT <i>column_name</i>,...<br>
  FROM <i>table_name</i>;</code>
</table>

<p>We start from examples without the WHERE clause. Here is the first query.</p>

<table><tr><td class="przyk">Display first name and last name of each employee.</table>

<p>We define the query as the following SQL statement:</p>

<table><tr><td class="notec">
<code>SELECT [First name], [Last name]<br>
FROM Employees;</code>
</table>

<p>In laboratory classes we will use MS Access to write and test queries. We can create an SQL statement
as follows.</p>

<ol>
<li>In the database window choose tab &quot;Queries&quot; and then click the item
	&quot;Create Query in Design View&quot;.
<li>Close the window &quot;Show Table&quot; without selecting anything.
<li>Select menu item &quot;File&quot; -&gt; SQL View&quot;.
	A window will appear.
<li>Type the text of the SQL statement into this window.
<li>Save it as a query and execute.
</ol>

<p>Here is the picture of what it looks like in MS Access:</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_02.png"></p>

<p>and the result of the query:</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_03.png"></p>

<p>The next query is even simpler.</p>

<table><tr><td class="przyk">
Display the whole content of the table <i>Employees</i>.
</table>

<p>As you probably expected, "all" is denoted by the asterisk:</p>

<table><tr><td class="notec">
<code>SELECT *<br>
FROM Employees;</code>
</table>


<p>The result will be as follows:</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_04.png"></p>

<p>Now it is your turn.  Write the query to answer the following question:</p>

<table><tr><td class="notec">
<a href="javascript:popUp('ok01.html',450,120)">Display</a>
the first name, the last name and the phone number of each employee.
</table> 


<p>The result of a query may be formatted freely. Instead of names of columns, you can use
any expressions.  Let us assume that we want to see text information on employees.
In order to concatenate strings, we use symbol '&amp;'. Keyword <code>AS</code>
allows renaming the label of an output column.</p>

<table><tr><td class="notec">
<code>SELECT [First name] &amp; " " &amp; [Last name] &amp; 
	" is employed as " &amp; [Job] AS [Emp info]<br>
FROM Employees;</code>
</table>

<p>Remember that brackets are used to isolate identifiers which
contain special characters, e.g. spaces.</p>

<p>Here is the result of this query:</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_05.png"></p>

<p>Again your turn.  Write the query that answers the following question:</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok02.html',500,150)">
Display</a> the full information on customers in the text form.
</table> 

<p>Further examples will have the WHERE clause. The next query is:</p>

<table><tr><td class="przyk">Display all managers.</table>

<p>The managers satisfy the condition <code>Job = "Manager"</code>.
We put it into the WHERE clause:</p>

<table><tr><td class="notec">
<code>SELECT [First name], [Last name]<br>
FROM Employees<br>
WHERE Job = "Manager";</code>
</table>

<p>The result is:</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_06.png"></p>

<p>Here is the next task for you:</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok03.html',600,140)">Display</a>
all customers with the first name "Ian".</table> 

<p>Let us consider the following problem:</p>

<table><tr><td class="przyk">Display phone numbers of employees without duplicates.
</table>

<p>The solution uses the keyword <code>DISTINCT</code> which eliminates the duplicates
from the resulting set of rows.</p>

<table><tr><td class="notec">
<code>SELECT DISTINCT Phone_no<br>
FROM Employees;</code>
</table>

<p>As a result we have four rows. One of them holds <code>NULL</code>
which
denotes the lack of value.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_07.png"></table>

<hr><h3><a name="orderby">ORDER BY</a></h3>

<p><code>ORDER BY </code> is an optional clause of SELECT statement which is used to order
rows in the result. This clause always occurs as the last one.  It has the following form:
</p>

<table><tr><td class="notec">
  <code>ORDER BY <i>column_name</i> <i>specifier</i>,...</code>
</table>

<p>The <code><i>specifier</i></code> is either <code>ASC</code> (ascending)
or <code>DESC</code> (descending).  The specifier is optional.  If you omit it, 
the ascending order is assumed.</p>

<table><tr><td class="przyk">Display employees in reverse order of their second names.
</table>

<p>We will use the specifier <code>DESC</code>:</p>
<table><tr><td class="notec">
<code>SELECT [First Name], [Last Name]<br>
FROM Employees<br>
ORDER BY [Last Name] DESC;</code>
</table>

<p>The result:</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_08.png"></p>

<p>We would get the ascending order if we wrote <code>ASC</code> instead of
<code>DESC</code>.</p>

<p>Here is another exercise for you.</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok04.html',600,170)">Display</a>
the information on customers ordered by second names.  If they are equal,
use first names.  If both the first and the second names are equal, use the identifiers.
</table> 

<hr><h3><a name="Operatory">Predicates</a></h3>

<h4>IS [NOT] NULL</h4>

<p>In order to test whether a value is <code>NULL</code>, use predicate
<b><code>IS NULL</code></b>. Predicate <b><code>IS NOT NULL</code></b> is its negation.</p>

<table><tr><td class="przyk">
Display employees who have no phone number.
</table>

<p>We use predicate <code>IS NULL</code>.</p>

<table><tr><td class="notec">
<code>SELECT [First Name], [Last Name]<br>
FROM Employees<br>
WHERE Phone_no IS NULL;</code>
</table>

<h4>[NOT] BETWEEN</h4>

<p>Predicate <b><code>BETWEEN</code></b> is true if the given value belongs to the
specified range  (the ends of the range are included).
Predicate <b><code>NOT BETWEEN</code></b> is its negation.</p>

<table><tr><td class="przyk">
Display employees with identifiers from the range between 2 and 4.
</table>

<p><table><tr><td class="notec">
<code>SELECT [First Name], [Last Name]<br>
FROM Employees<br>
WHERE Emp_id BETWEEN 2 AND 4;</code>
</table></p>

<p>Predicate <code>BETWEEN</code> is equivalent
to the conjunction of two inequalities, e.g.</p>

<table><tr><td class="notec">
<code>Emp_id &lt;= 2 AND Emp_id &gt;= 4</code>.
</table>

<p>Which form would you prefer?</p>

<h4>[NOT] LIKE</h4>

<p>Predicate <b><code>LIKE</code></b> is true if the given value matches the specified
pattern. Predicate <b><code>NOT LIKE</code></b> is its negation.
We remind you that the asterisk in the pattern matches any text (even empty),
the question mark matches any character and the hash matches any digit.</p>

<table><tr><td class="przyk">
Display employees with last names that begin with "K".
</table>

<p><table><tr><td class="notec">
<code>SELECT [First Name], [Last Name]<br>
FROM Employees<br>
WHERE [Last name] LIKE "K*";</code>
</table></p>

<p>Here is another task for you.</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok05.html',550,170)">Display</a>
customers with last names that begin with "K" and end with "s".
</table> 

<h4>[NOT] IN</h4>

<p>Predicate <b><code>IN</code></b> is true, if the given value belongs to the
specified set. Predicate <b><code>NOT IN</code></b> is its negation.</p>

<table><tr><td class="przyk">
Display employees with managerial jobs.
</table>

<p><table><tr><td class="notec">
<code>SELECT [First Name], [Last Name]<br>
FROM Employees<br>
WHERE Job IN ("Manager", "Director", "CEO");</code>
</table></p>

<p>Predicate <code>IN</code> is equivalent
to the disjunction of equalities, e.g.</p>

<table><tr><td class="notec">
<code>Job = "Manager" OR Job = "Director" OR Job = "CEO"</code>
</table>

<p>Which form would you prefer?</p>

<h4>OR, AND, NOT</h4>

<p>Atomic predicates can be combined by logical connectives:
the disjunction (<b><code>OR</code></b>), the conjunction (<b><code>AND</code></b>)
and the negation (<b><code>NOT</code></b>).</p>

<table><tr><td class="przyk">
Display employees who have a phone number and second names that end with "K".
</table>

<p>It is the conjunction of simple predicates.</p> 


<table><tr><td class="notec">
<code>SELECT [First Name], [Last Name]<br>
FROM Employees<br>
WHERE [Last name] LIKE "K*" AND Phone_no IS NOT NULL;</code>
</table>

<p>Please write a query which answers the following question.</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok06.html',550,180)">Display</a>
customers who have no phone number or no address.
</table> 

<hr><h3><a name="Insert">INSERT statement</a></h3>

<p>The <b><code>INSERT</code></b> statement is used to add rows to a table. It consists of two
clauses <b><code>INTO</code></b> and <b><code>VALUES</code></b>.</p>

<table><tr><td class="notec">
<code>INSERT INTO <i>table_name</i>(<i>column_name</i>,...)<br>
VALUES(<i>value</i>,...);</code>
</table>

<p>A column which is not listed in clause <code>INTO</code> is set to <code>NULL</code>
in the new row, unless it is of type <code>Autonumber</code> or 
default values have
been set for it.</p>

<table><tr><td class="przyk">
Add a new employee to table <i>Employees</i>.
</table>

<p><table><tr><td class="notec">
<code>INSERT INTO Employees([First Name], [Second name], Job)<br>
VALUES("Adam", "Blake", "CEO");</code>
</table>

<p>Two columns of the table <i>Employees</i> are absent in this statement.
<i>Emp_id</i> will be automatically set to the next sequence number, while
<i>Phone_no</i> will be <code>NULL</code>.
</p>

<hr><h3><a name="Delete">DELETE statement</a></h3>

<p>The <b><code>DELETE</code></b> statement is used to delete rows from a table.
It consists of two clauses <b><code>FROM</code></b> and <b><code>WHERE</code></b>.
The latter clause is optional.
</p>

<table><tr><td class="notec">
<code>DELETE FROM <i> table_name</i><br>
[WHERE <i>condition</i>];</code>
</table>

<p>The rows which satisfy the <code><i>condition</i></code> will be deleted
from table <code><i>table_name</i></code>.  If the clause <code>WHERE</code> is missing,
all rows from the table are deleted.</p>

<table><tr><td class="przyk">
From the table <i>Employees</i> delete all rows on persons employed as managers.
</table>

<p><table><tr><td class="notec">
<code>DELETE FROM Employees<br>
WHERE Job = "Manager"</code>
</table>

<hr><h3><a name="Update">UPDATE statement</a></h3>

<p>The <b><code>UPDATE</code></b> statement is used to modify rows of a table.
It consists of three clauses <b><code>UPDATE</code></b>,
<b><code>SET</code></b> and <b><code>WHERE</code></b>.  Only <code>WHERE</code>
is optional.</p>

<table><tr><td class="notec">
<code>UPDATE <i>table_name</i><br>
SET <i>column_name</i>= <i>expression</i>, ...<br>
WHERE <i>condition</i>;</code>
</table>

<p>The rows of table <code>table_name</code> which satisfy the <code>condition</code>
will be updated.  The modification will consist in performing assignments
<code><i>column_name</i>= <i>expression</i></code> for each column
which occurs on the left side of the equality sign in clause <code>SET</code>.</p>

<table><tr><td class="przyk">
In the table <i>Employees</i> change the phone number "4565666" to "1265666".
</table>

<p><table><tr><td class="notec">
<code>UPDATE Employees<br>
SET Phone_no = "1265666"<br>
WHERE Phone_no = "4565666";</code>
</table>

<p>Here is an exercise for you.</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok07.html',400,130)">In</a>
table <i>Customers</i> change <code>NULL</code> phone no. values to text <code>"NONE"</code>.
</table> 

<hr><h3><a name="UNION">UNION</a></h3>

<p>You can combine the results of several SELECT statements provided they return 
the same number of columns which have the same types.</p>

<table><tr><td class="notec">
<code><i>SELECT_statement</i> UNION <i>SELECT_statement</i></code>
</table>

<p>This form of a query cannot be created by means of the query grid. You have to
use the SQL view. To reach the SQL view, just open the query in the design view and
them switch to the SQL view or select menu item &quot;Query -&gt; SQL
Specific -&gt; UNION&quot;.</p>

<table><tr><td class="przyk">
Display last names of employees and customers. Precede each name of an employee
with the word "Employee" and each name of a customer with the word "Customer".
</table>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_09.png"></p>

<p>The result:</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_10.png"></p>

<p>Among items in menu "Query -&gt; SQL Specific" there are two more.</p>

<dl>
<dt><i>Data Definition</i>
<dd>A data definition statement: the creation of a table (<code>CREATE TABLE</code>),
	a change of the schema of a table (<code>ALTER TABLE</code>), 
	the deletion of a table (<code>DROP TABLE</code>). They will be presented during
	the sequel lecture <i>Database systems</i>.
<dt><i>Pass-Through</i>
<dd>An SQL statement to be executed by a remote database.  Its syntax must be understandable
for this database. In order to create a pass-through query, you have to define a DSN
for an external data source.
</dl>
 
<hr><h3><a name="INNER JOIN">Inner join</a></h3>

<p>Now we will discuss more complex SELECT statements with joins.
Here is a typical question which can be solved with a join.</p>

<table><tr><td class="przyk">
Display customers and the identifiers of their invoices.</table>

<p>We will use a method which can be used in many other cases. We will design the
query by means of the query grid in the design view.  Then we switch to the SQL view to
obtain the text of the desired SQL statement.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_11.png"></p>

<p>The SQL view shows the corresponding SQL statement.</p>

<table><tr><td class="notec">
<code>SELECT  Customers.[First name], Customers.[Last name], Invoices.Inv_id<br>
FROM Customers INNER JOIN Invoices ON Customers.Cust_id = Invoices.Cust_id;</code>
</table>

<p>It is an <code>INNER JOIN</code> of tables <i>Customers</i> and
<i>Invoices</i>.  The join conditions uses the connection <b>primary key-foreign key</b>.
Here is the general syntax of the inner join of two tables which can be used
in clause <code>FROM</code>.</p>

<table><tr><td class="notec">
<code><i>Table</i><sub>1</sub> INNER JOIN <i>Table</i><sub>2</sub> ON
<i>Table</i><sub>1</sub>.<i>column</i><sub>1</sub> =
<i>Table</i><sub>2</sub>.<i>column</i><sub>2</sub></code>
</table>

<p>The names of columns are prefixed with the names of tables. In the case of column
<i>Cust_id</i> it is unavoidable because otherwise  
the query engine would have no means to recognize what table the column came from.
This name of the column occurs in both tables.</p>

<p>The inner join can be specified without the operator <code>INNER JOIN</code>.  Simply, put
the join condition into the <code>WHERE</code> clause of the query.</p>

<table><tr><td class="notec">
<code>FROM <i>Table</i><sub>1</sub>, <i>Table</i><sub>2</sub><br>
WHERE <i>Table</i><sub>1</sub>.<i>column</i><sub>1</sub> =
<i>Table</i><sub>2</sub>.<i>column</i><sub>2</sub></code>
</table>

<p>Therefore, the previous query can also be formulated as follows:</p>

<table><tr><td class="notec">
<code>SELECT  Customers.[First name], Customers.[Last name], Invoices.Inv_id<br>
FROM Customers, Invoices<br>
WHERE Customers.Cust_id = Invoices.Cust_id;</code>
</table>

<p>It is time for another task for you.</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok08.html',500,150)">
For</a> each product display its name, prices and the identifier of invoices 
where the product occurs. Show also the ordered quantities.
</table> 

<hr><h3><a name="outer-join">Outer join</a></h3>

<p>Let us consider the following query.</p>

<table><tr><td class="przyk">
Display employees and the orders they have collected.
</table>

<p>As before, we will use the query grid:</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_12.png"></p>

<p><a name="OUTER JOIN">The join</a> between employees and invoices is
outer, i.e.  invoices which are not assigned to any employee are also shown. 
In rows which represent such invoices first name and second name are
empty.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_13.png"></p>

<p>The SQL view shows the corresponding SQL statement.</p>

<table><tr><td class="notec">
<code>SELECT Employees.[First name], Employees.[Last name], Invoices.Inv_id<br>
FROM Employees RIGHT JOIN Invoices ON Employees.Emp_id = Invoices.Emp_id<br>
ORDER BY Invoices.Inv_id;
</code></table>

<p>It is a <code>RIGHT OUTER JOIN</code> of tables <i>Employees</i> and
<i>Invoices</i>.  Here is the general syntax of the outer join of two
tables which can be used in the clause <code>FROM</code>.</p>

<table><tr><td class="notec">
<code><i>Table</i><sub>1</sub> RIGHT OUTER JOIN <i>Table</i><sub>2</sub> ON
<i>Table</i><sub>1</sub>.<i>column</i><sub>1</sub> =
<i>Table</i><sub>2</sub>.<i>column</i><sub>2</sub></code>
</table>

<p>Such an expression means that the query engine is to display all rows of
<code><i>Table</i><sub>2</sub></code> (the one that is on the <u>right</u> side) regardless
of whether there are matching rows of <code><i>Table</i><sub>1</sub></code>.
If we use <code>LEFT</code> instead of <code>LEFT</code>, all rows of 
<code><i>Table</i><sub>1</sub></code> (the one that is on the <u>left</u> side)
will be shown.</p>

<hr><h3><a name="distinct">DISTINCT, DISTINCTROW</a></h3>

<p>The operator <code>DISTINCTROW</code> is not an element of the standard SQL. 
The operator <code>DISTINCT</code> has been used in one of the examples at the beginning
of this lecture.  It orders the query engine to eliminate the duplicates.</p>

<p>We will present the differences between the two operators using three versions of 
the same example query (the inner join of <i>Customers</i> and <i>Invoices</i>):

<ul>
<li>with neither <code>DISTINCT</code> nor <code>DISTINCTROW</code>,
<li>with <code>DISTINCTROW</code> and
<li>with <code>DISTINCT</code>.
</ul>

<h4>Neither DISTINCT nor DISTINCTROW</h4>

<p>The result of the following query contains duplicates:</p>

<table><tr><td class="notec">
<code>SELECT  Customers.[First name], Customers.[Last name]<br>
FROM Customers INNER JOIN Invoices ON Customers.Cust_id = Invoices.Cust_id;</code>
</table>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_14.png"></p>

<h4>DISTINCTROW</h4>

<p>The result of the following query contains one pair of duplicates:</p>

<table><tr><td class="notec">
<code>SELECT DISTINCTROW Customers.[First name], Customers.[Last name]<br>
FROM Customers INNER JOIN Invoices ON Customers.Cust_id = Invoices.Cust_id;</code>
</table>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_15.png"></p>

<p>If you use <code>DISTINCTROW</code>, the query engine will create a separate output
row for each <u>row</u> of table <i>Customers</i>.  In this table there are two persons
called <i>Mary Johnson</i>. They have different identifiers and each of them has at least
one invoice.  Therefore, we get a separate output row for each input row with <i>Mary Johnson</i>.</p>

<h4>DISTINCT</h4>

<p>The result of the following query contains no duplicates:</p>

<table><tr><td class="notec">
<code>SELECT DISTINCT Customers.[First name], Customers.[Last name]<br>
FROM Customers INNER JOIN Invoices ON Customers.Cust_id = Invoices.Cust_id;</code>
</table>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_16.png"></p>

<p>If you use <code>DISTINCT</code>, the query engine will create a separate output
row for each different <u>value</u> taken from table <i>Customers</i>.  Thus, the records
with <i>Mary Johnson</i> are collapsed. Of course, if we added column <i>Cust_id</i>
(the primary key), both <code>DISTINCT</code> and <code>DISTINCTROW</code> would yield
the same result.</p>

<hr><h3><a name="SELF JOIN">Self-join</a></h3>

<p>There is one more specific kind of join, called <i>the self-join</i>.
It is the join of a table with itself.  Its join condition is usually
based on the pair <i>primary key-foreign key</i> of a recursive relationship.</p>

<p>Let us consider the parenthood relationship.  We will represent it in the table
<i>Persons</i>.  Each of its rows contains the information on the mother and
the father.  It is stored in two foreign keys: <i>Mother</i> and <i>Father</i>
which
reference the primary key of the same table. In order to define such recursive relationships, 
you have to show this table three times on the relationship diagram of MS Access.
This is different from MS Visio where we show the same table only once. </p>


<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_17.png"></p>

<p>We want to see the table which shows the name of each 
person together with the names of his/her father and mother.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_18.png"></p>

<p>In order to define such a query, we use three virtual copies of 
the table <i>Persons</i>:</p>

<ol>
<li><b>Persons</b> - represents the person whose parents are to be displayed
<li><b>Fathers</b> - represents the father,
<li><b>Mothers</b> - represents the mother.
</ol>

<p>We introduce two latter aliases in the clause <code>FROM</code> of the query.
One copy need no alias, because it is used under the name of the table.</p>

<table><tr><td class="notec">
<code>SELECT Persons.Name, Fathers.Name AS Father, Mothers.Name AS Mother<br>
FROM (<b>Persons</b> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LEFT JOIN Persons AS <b>Mothers</b> ON Persons</b>.Mother = Mothers.Person_id)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LEFT JOIN Persons AS <b>Fathers</b> ON Persons</b>.Father = Fathers.Person_id;</code>
</table>

<p>This query can be constructed in the query grid as well. We simply add the same table three times.
We have to add the relationships because they are not created automatically.
Make the query an outer join,
because we want to see persons whose parents are not stored in the database.  If we use the inner join, we will see only
those whose mother and father are both inserted into the database.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_19.png"></p>

<p>Here is a task for you.</p>

<p><table><tr><td class="notec"><a href="javascript:popUp('ok09.html',750,220)">
List</a> persons and for each person display the names of his/her grandfathers.
</table> 

<hr><h3><a name="Aggr-fun">Aggregate functions</a></h3>

<p>Aggregate functions play a special role in queries.
Here are their semantics:

<dl>
<dt><code>COUNT()</code>
<dd>The number of values in a column.
<dt><code>MAX()</code>
<dd>The maximal value in a column.
<dt><code>MIN()</code>
<dd>The minimal value in a column. 
<dt><code>SUM()</code>
<dd>The sum of values in a column.
<dt><code>AVG()</code>
<dd>The average value in a column.
</dl>

All rows are taken into account in these calculations.
The only argument of each of these functions indicates the column to be used.
Instead of a column you can also use any expression. For example, the following query:</p>

<table><tr><td class="notec"><code>
SELECT Count(Prod_id), Min(Price), Max(Price), Sum(Price), Avg(Price)<br>
FROM Products;
</code></table>

<p>Produces one row with the number of rows in the table 
<i>Products</i>, the minimum price,
the maximum price, the sum of the prices and the average price.</p>

<table><tr><td class="notec">
Please type this query into MS Access in the SQL view, and then switch to the design view to see
what the query looks like in the query grid.
</table> 

<hr><h3><a name="GROUP BY">GROUP BY</a></h3>

<p>The clause <code>GROUP BY</code> partitions rows into groups
and calculates
totals inside these groups.  Let us consider the following query:</p>

<table><tr><td class="przyk">
Display the number of invoices of every customer.
</table>

<p>As before we will use the query grid. We will enrich it by adding the row with totals.
To do it, we select the menu item &quot;View -&gt; Totals&quot;.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_20.png"></p>


<p>We choose &quot;Group by&quot; for columns <i>Cust_id</i> and <i>Last
Name</i> and the aggregate function (&quot;Count&quot;) for column
<i>Inv_id</i>.  We precede the call to this function with the name for this
column, i.e. <i>No_of_invs</i>.  As a result we get the number of invoices
of every customer.</p>


<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_21.png"></p>

<p>The SQL view shows the corresponding SQL statement.</p>

<p><table><tr><td class="notec"><code>
SELECT Customers.Cust_id, Customers.[Last name], Count(Invoices.Inv_id) AS No_of_invs<br>
FROM Customers INNER JOIN Invoices ON Customers.Cust_id = Invoices.Cust_id<br>
GROUP BY Customers.Cust_id, Customers.[Last name]<br>
ORDER BY Customers.[Last name];
</code></table>


<p>The clause <code>GROUP BY</code> appeared just below the clause
<code>FROM</code>.  It told the database engine
to partition the rows as the results of the 
<code>INNER JOIN</code>. The clause
<code>SELECT</code> specifies the values which must be displayed
for all the groups defined by the clause <code>GROUP BY</code>.  The clause
<code>SELECT</code> may contain columns which are listed by the clause
<code>GROUP BY</code> as well as the calls to aggregate functions on the
columns not listed by the clause <code>GROUP BY</code>.</p>


<table><tr><td class="notec"><code>GROUP BY <i>column</i>, ....</code></table>

<p>Here is a task for you:</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok10.html',750,160)">For</a>
every product display its name, price, the number of invoices with it
and the total value of it on all invoices.</table> 

<p>Consider the next query.</p>

<table><tr><td class="przyk">
For every employee display the number of invoices signed by him/her.
</table>

<p>This time we will use the outer join of the tables <i>Invoices</i> and 
<i>Employees</i>. We will also display the employees who signed no
invoices, but we will not show the invoices signed by no employees. We design this query
in the query grid.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_22.png"></p>

<p>In the result table there are rows which describe employees who signed no invoices.
For such employees the column <code>No_of_invs</code> is equal to zero.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_23.png"></p>

<p>The SQL view shows the corresponding SQL statement.</p>

<table><tr><td class="notec"><code>
SELECT Employees.Emp_id, Employees.[Last name], Count(Invoices.Inv_id) AS No_of_invs<br>
FROM Employees LEFT JOIN Invoices ON Employees.Emp_id = Invoices.Emp_id<br>
GROUP BY Employees.Emp_id, Employees.[Last name];
</code></table>

<hr><h3><a name="HVING">HAVING</a></h3>

<p>If you want to filter rows, you use the clause <code>WHERE</code>. There is also a similar
clause but it is used to filter groups. This is the clause <code>HAVING</code>.</p>

<table><tr><td class="notec"><code>GROUP BY <i>column</i>, ....<br>
HAVING <i>condition</i></code></table>

<p>The clause <code>HAVING</code> filters groups and not rows. 
It can contain columns
listed by the clause <code>GROUP BY</code> as well as the calls to aggregate functions on columns
not listed by the clause <code>GROUP BY</code>.  If in the previous example we asked to display 
only these employees who had signed at least three invoices, we would add appropriate
content of the clause <code>HAVING</code></p>

<table><tr><td class="notec"><code>
SELECT Employees.Emp_id, Employees.[Last name], Count(Invoices.Inv_id) AS No_of_invs<br>
FROM Employees LEFT JOIN Invoices ON Employees.Emp_id = Invoices.Emp_id<br>
GROUP BY Employees.Emp_id, Employees.[Last name]<br>
HAVING Count(Invoices.Inv_id) >= 3;
</code></table>

<hr><h3><a name="Zas">Evaluation rules for SELECT</a></h3>

<ol>
<li>If a query contains calls to operator <code>UNION</code>, repeat steps 2-7
	for all its arguments.
<li>Evaluate tables listed by the clause <code>FROM</code>. Apply operators
	<code>INNER JOIN</code>, <code>LEFT JOIN</code> and <code>RIGHT JOIN</code>.
	Consider all tuples of resulting rows.
<li>Apply the condition <code>WHERE</code> to all these tuples. Retain only those that
	yield <code>True</code> for this condition. Drop all the others, i.e. those that
	yield <code>False</code> or <code>Null</code>.
<li>Partition the retained rows into groups according to the specification in
	the clause <code>GROUP BY</code>.
<li>Apply the condition <code>HAVING</code> to all these groups. Retain only those that
	yield <code>True</code> for this condition. Drop all the other, i.e. those that
	yield <code>False</code> or <code>Null</code>.
<li>For each retained group, evaluate the expression listed by the clause <code>SELECT</code>.
<li>If there is <code>DISTINCT</code> or <code>DISTINCTROW</code> after <code>SELECT</code>,
	remove duplicates from the resulting rows. 
<li>Apply the operator <code>UNION</code>, if it is present.
<li>Apply the clause <code>ORDER BY</code> (i.e. sort resulting rows), if it is present. 
</ol>

<p>The above rules should be treated only as the operational semantics of the SQL queries.
Database systems evaluate queries in a more efficient way.  For example, they never calculate
all tuples of the rows from the base tables listed by the clause <code>FROM</code>.
In the sequel subject "Database systems" the evaluation of queries will be further
elaborated upon.
</p>

<hr><h3><a name="Parametry">Parameterized queries</a></h3>

<p>It is sometimes convenient to create a query which depends on some parameters, e.g.
the name of a person or a company. Here is the method to create such queries in the query
grid.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_24.png"></p>

<p>This query is equivalent to the following SQL statement.</p>

<table><tr><td class="notec"><code>
SELECT DISTINCTROW Customers.[Last name], Products.Name<br>
FROM Customers INNER JOIN (Invoices INNER JOIN ([Line Items] INNER JOIN Products<br>
&nbsp;&nbsp;ON Products.Prod_id = [Line Items].Prod_id)<br>
&nbsp;&nbsp;ON Invoices.Inv_id = [Line Items].Inv_id)<br> 
&nbsp;&nbsp;ON Customers.Cust_id = Invoices.Cust_id<br> 
WHERE Customers.Cust_id=[Enter customer id];
</code></table>

<p>when the system starts to evaluate this query, it displays a window where the user
enters the value of the parameter.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_25.png"></p>

<p>As a result we get the list of products bought by the customer identified by 7.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_26.png"></p>

<hr><h3><a name="Podzapytania">Subqueries</a></h3>

<p>You might have noticed we have not discussed an important feature which is present
in programming languages, i.e. the composition of statements. It is natural to compose
statements in the structured approach to solving problems. If we use this method,
we divide the problem into subproblems, we solve the subproblems and then we compose
these solution appropriately to obtain the solution to the main problem. SQL means
<i><u>Structured</u> Query Language</i>. Thus it provides for this method of
solving problems. Let us consider a problem with a subproblem which is easy to identify.</p>

<table><tr><td class="przyk">Display the product with the highest price.</table>

<p>Here, the subproblem is <u>to find the highest price</u>. It can be solved by the following
query.</p>

<table><tr><td class="notec"><code>
SELECT MAX(Price)<br>
FROM Products;
</code></table>

<p>This query computes the highest value in column <i>Price</i> in table <i>Products</i>.
We will use it to solve the main problem.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_27.png"></p>

<p>As the result we get the following.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_28.png"></p>

<p>If we switch to the SQL view, we will see the following statement.</p>

<table><tr><td class="notec"><code>
SELECT Products.Name, Products.Price<br>
FROM Products<br>
WHERE Products.Price=(SELECT MAX(Price) FROM Products);
</code></table>

<p>The condition <code>Products.Price=(SELECT MAX(Price) FROM Products)</code> states
that we are interested in products which have price equal to the price of the most
expensive product.</p>

<p>Here is another task for you.</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok11.html',700,350)">Display</a>
the product with the biggest quantity on a single invoice.</table> 

<h4>Correlated subqueries</h4>

<p>So far in subqueries we have not used the columns from the superquery. Such
subqueries are called <i>uncorrelated</i>.  The result of such a subquery does not
depend on the rows from the superquery.</p>

<p>A subquery is <i>correlated</i>, if its result depends on the values of columns of the
rows of the superquery.</p>

<p>Let us consider the following query.</p>

<table><tr><td class="przyk">
For every invoice display the name of the most expensive product on this invoice.
</table>

<p>We want to obtain the following result.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_29.png"></p>

<p>First, we solve this problem but for a while we assume that we are able to
solve the subproblem, i.e. we can find the price of the most expensive product
on the invoice identified by <font color="red"><code>Invoices.Inv_id</code></font>.
This red phrase
occurs in the superquery and the it is used in the subquery. Therefore it
<i>correlates</i> the subquery and the superquery.</p>

<table><tr><td class="notec"><code>
SELECT <font color="red"><code>Invoices.Inv_id</code></font>, Products.Name, Products.Price<br>
FROM Products INNER JOIN (Invoices INNER JOIN [Line Items]<br>
&nbsp;&nbsp;ON Invoices.Inv_id = [Line Items].Inv_id)<br>
&nbsp;&nbsp;ON Products.Prod_id = [Line Items].Prod_id<br>
WHERE Products.Price =
<u>The most expensive product on invoice <font color="red"><code>Invoices.Inv_id</code></font></u><br>
ORDER BY <font color="red"><code>Invoices.Inv_id</code></font>;
</code></table>

<p>Then we solve the subproblem.</p>

<table><tr><td class="notec"><code>
SELECT MAX(Price)<br>
FROM Products INNER JOIN [Line items]<br>
&nbsp;&nbsp;ON Products.Prod_id = [Line Items].Prod_id<br>
WHERE <font color="red"><code>Invoices.Inv_id</code></font> = [Line Items].Inv_id;
</code></table>

<p>After we compose these two solutions, we will have the complete solution to the main problem.</p>

<table><tr><td class="notec"><code>
SELECT <font color="red"><code>Invoices.Inv_id</code></font>, Products.Name, Products.Price<br>
FROM Products INNER JOIN (Invoices INNER JOIN [Line Items]<br>
&nbsp;&nbsp;ON Invoices.Inv_id = [Line Items].Inv_id)<br>
&nbsp;&nbsp;ON Products.Prod_id = [Line Items].Prod_id<br>
WHERE Products.Price =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(SELECT MAX(Price)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM Products INNER JOIN [Line items]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ON Products.Prod_id = [Line Items].Prod_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE <font color="red"><code>Invoices.Inv_id</code></font> = [Line Items].Inv_id);
</code></table>

<p>The subquery of this query is correlated, because a column from the superquery
(<font color="red"><code>Invoices.Inv_id</code></font>) is used in the subquery
and influences its result.</p>

<p>Here is another task for you.</p>

<table><tr><td class="notec">
<a href="javascript:popUp('ok12.html',650,440)">Display</a>
the invoice with the highest total value.</table> 

<p>In MS Access a subquery may occur only on the right-hand side of a binary
operator (the latest SQL standard no longer places this limitation) and must return a single
value, unless it is one of the following:

<dl>
<dt><code>IN</code> or <code>NOT IN</code> 
<dd>Both accept subqueries which return lists of values.
<dt><code>EXISTS</code> or <code>NOT EXISTS</code>
<dd>Both accept any subqueries.
</dl>

<p>Here is an example of a query with the operator <code>IN</code> that is used to
find employees who signed at least one invoice.</p>

<table><tr><td class="notec"><code>
SELECT Employees.[First name], Employees.[Last name]<br>
FROM Employees<br>
WHERE Emp_id IN (SELECT Emp_id FROM Invoices);
</code></table>

<p>It seems that by means of <code>NOT IN</code>
we can analogously find the employees who signed no invoices.</p>

<table><tr><td class="notec"><code>
SELECT Employees.[First name], Employees.[Last name]<br>
FROM Employees<br>
WHERE Emp_id NOT IN (SELECT Emp_id FROM Invoices);
</code></table>

<p>To our surprise, this query displays no rows in spite of the fact 
that we have a number of such employees in the database.</p>

<p>This is caused by the presence of <code>NULL</code> values. We cannot tell that
a value is different from <code>NULL</code>.  Some invoices are signed by no employees.
For such invoices the column <code>Invoices.Emp_id</code> contains
the value <code>NULL</code>.</p>

<h4>EXISTS and NOT EXISTS</h4>

<p>The operator <code>EXISTS</code> allows checking whether a subquery yields the empty result
or not. For example the following condition checks if at least one employee works as 
a manager.</p>

<table><tr><td class="notec"><code>
EXISTS (SELECT "x" FROM Employees WHERE Job = "Manager")
</code></table>

<p>The truth of this condition does not depend on the content of the clause <code>SELECT</code>.
We suggest using a value that is easiest to compute, e.g. <code>"x"</code>.</p>

<p>The first example uses <code>EXISTS</code>.</p>

<table><tr><td class="przyk">Find employees who signed at least one invoice.</table>

<p>Here is the solution.</p>

<table><tr><td class="notec"><code>
SELECT Employees.[First name], Employees.[Last name]<br>
FROM Employees<br>
WHERE EXISTS (SELECT "x" <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM [Invoices] <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE Invoices.Emp_id = Employees.Emp_id);
</code></table>

<p>Now return to the problem we did not solve before by means of the operator
<code>NOT IN</code>.</p>

<table><tr><td class="przyk">Find employees who signed no invoices.</table>

<p>Here is the solution which uses the operator <code>NOT EXISTS</code>.</p>

<table><tr><td class="notec"><code>
SELECT Employees.[First name], Employees.[Last name]<br>
FROM Employees<br>
WHERE NOT EXISTS (SELECT "x" <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM [Invoices] <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE Invoices.Emp_id = Employees.Emp_id);
</code></table>

<p>This time the result is correct.</p>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_30.png"></p>

<p>At the end of the lecture let us consider the following problem.</p>

<table><tr><td class="przyk">
Select customers who are also employees of the company.
</table>

<p>The SQL standard defines an operator (<code>INTERSECT</code>)
which can be used here.
It is the intersection of relations.  If MS Access provided that operator, 
We would intersect two queries to tables <i>Customers</i> and <i>Employees</i>
respectively.  MS Access does not have this implemented,
instead you can use a subquery and the operator <code>NOT EXISTS</code>.</p>

<table><tr><td class="notec"><code>
SELECT [First name], [Last name]<br>
FROM Customers<br>
WHERE EXISTS (SELECT "x" <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM Employees<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE Employees.[First name] = Customers.[First name]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND  Employees.[Last name] = Customers.[Last name]);
</code></table>

<p>This query returns no rows from our sample database. There are no customers
who are
also employees. Of course, you can question the test on a person's identity
based on the first and last names.  However, our sample database contains no precise
information on a person's identity like the SSN.</p>

<p>The SQL standard defines also another set operation, the difference (<code>EXCEPT</code>).
MS Access does not implement it as well.  Instead of it, you can use
a subquery and the operator <code>NOT EXISTS</code>. with this hint you can easily write
the following query.</p>

<table><tr><td class="notec"><a href="javascript:popUp('ok13.html',710,180)">Select</a>
customers that are not employed by the company.
</table> 

<hr><h3><a name="Podsumowanie">Summary</a></h3>

<p>Lecture 9 was devoted to SQL, i.e. the standard language which allows accessing
and updating data stored in relational (or object-relational) databases.  It is widely accepted
and implemented by all vendors of database systems.</p>

<p>We presented the following statements:
the addition of a new row into a table (<code>INSERT</code>),
the deletion of a row from a table (<code>DELETE</code>),
the update of a row of a table (<code>UPDATE</code>) and
the retrieval of data from a number of tables (<code>SELECT</code>).</p>

<p>A query to a database (the <code>SELECT</code> statement) may contain several parts
called <i>clauses</i>. 
Clause <code>SELECT</code> defines the values which are to be retrieved from the database.
Clause <code>FROM</code> indicates the base tables to calculate these values from.
Clause <code>WHERE</code> states the condition which must be satisfied by these values.
Clause <code>GROUP BY</code> sets the partition of these values 
	into groups which must
be performed before returning the result of the query. 
Clause <code>HAVING</code> states the condition which must be satisfied by these groups.
Clause <code>ORDER BY</code> describes how to sort the returned rows.

<p>There are also two additional operators which can be used while building the queries.
They are the possibility to nest a subquery into a superquery and 
the set union (<code>UNION</code>) which combines the results of two queries.</p>

<p>During the sequel lecture <i>Database systems</i> SQL will be presented
in more detail.</p>

<hr><h3><a name="Slownik">Dictionary</a></h3>

<dl>
<dt><a href="#Delete">DELETE</a>
<dd>The SQL statement which is used
	to delete data from the database.
<dt><a href="#GROUP BY">GROUP BY</a>
<dd>A clause of <code>SELECT</code> statements.
	It is used to partition the rows into groups.
<dt><a href="#Insert">INSERT</a>
<dd>The SQL statement that is used
	to add new data to the database.
<dt><a href="#Parametry">parameterized query</a>
<dd>A query that contains parameters. Their values are usually supplied by the user
	before the execution of this query.
<dt><a href="#Select">SELECT</a>
<dd>The SQL statement which is used
	to retrieve data from the database.

<dt><a href="#Sql">SQL</a> (= Structured Query Language)
<dd>The standard language which allows accessing and processing the data stored in a relational database.
	It is a widely accepted international standard. 
	It is implemented by all vendors of database systems.
<dt><a href="#INNER JOIN">SQL join</a>
<dd>A join defined by one of the following operators:
	<code>INNER JOIN</code>,
	<code>LEFT JOIN</code> and
	<code>RIGHT JOIN</code>.
<dt><a href="#Operatory">SQL operator</a>
<dd>One of the following:
	<code>IS [NOT] NULL</code>, 
	<code>[NOT] BETWEEN</code>, 
	<code>[NOT]</code>,
	<code>LIKE</code>,
	<code>[NOT] IN</code>, 
	<code>[NOT] EXISTS</code>, 
	<code>UNION</code>, 
	<code>DISTINCT</code> and 
	<code>DISTINCTROW</code>.
<dt><a href="#Podzapytania">subquery</a>
<dd>A query nested inside another query. It may be uncorrelated or correlated with
	its superquery.
<dt><a href="#UNION">UNION</a>
<dd>The operator that performs the set union.
	It combines the results of two queries.
<dt><a href="#Update">UPDATE</a>
<dd>The SQL statement that is used
	to update the data stored in the database.
</dl>

<hr><h3><a name="Zadania">Exercise</a></h3>

<p align="center"><img border="0" src="https://gakko.pjwstk.edu.pl/materialy/2398/lec/wyklad09/images/9_31.png"></p>

<p>Build SQL statements for the following queries. Assume the above schema.</p>

<ol>
<li>List persons who earn between 1000 and 3000.
<li>List persons who earn more than 1500 and whose job is an accountant or a salesman.
<li>List all persons. Show the name and the location of the department of each person.
<li>List persons who work in Warsaw.
<li>For every department show the sum of the salaries of all its employees.
	Take into consideration the departments that employ no one.
<li>List all persons. Show the name of the manager of every person.
	Take into consideration the persons who have no manager.
<li>For each person show the number of people managed by this person.
<li>List persons who manage themselves.
<li>Show persons with the lowest salary.
<li>Check whether there are persons with the same names.
</ol>
